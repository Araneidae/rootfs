#!/bin/bash
# Simple populate script: simply populates from a hard-wired list.
#
# Should be called with the following environment variables set:
#
: ${sysroot:?}          # Root of rootfs being constructed
: ${BINUTILS_DIR:?}     # Root of binutils directory
: ${install_list:?}     # File containing list of installed files
: ${LIB_PREFIX:?}       # Directory of locally generated libraries

# The following environment variables are optional
#
#  TERMS                  List of terminals to install
#  EXTRA_LIBS             Extra libraries to be installed
#  COMPILER_PREFIX        Must be set if cross compiling


HERE="$(dirname "$0")"
set -o pipefail


. "$HERE"/functions

# We have two notions of sysroot here.  $sysroot is the root of the *target*
# filesystem that we're building, while $SYSROOT defined here is the glibc
# sysroot: in effect we're copying $SYSROOT -> $sysroot.
if [ -n "$COMPILER_PREFIX" ]; then
    SYSROOT="$BINUTILS_DIR/$COMPILER_PREFIX/sys-root"
    CROSS_COMPILE=$COMPILER_PREFIX-
else
    SYSROOT=/
    CROSS_COMPILE=
fi

READELF="$CROSS_COMPILE"readelf



install_terminfo()
{
    for term; do
        local dir=/usr/share/terminfo/${term::1}  
        mkdir -p "$sysroot/$dir"  &&
        cp "$SYSROOT/$dir/$term" "$sysroot/$dir"  ||  return 1
    done
}



# Searches for given library in lib and usr/lib, optionally searching for
# match to suffixes as well.  Called as:
#
#   locate_library <library> [<suffixes>]
#
locate_library()
{
    local lib="$1"
    shift

    local lib_dir lib_prefix
    for lib_prefix in "$SYSROOT" "$LIB_PREFIX"; do
        for lib_dir in lib usr/lib; do
            if (($#)); then
                for suffix; do
                    for file in "$lib_prefix/$lib_dir/$lib"$suffix; do
                        if [ -e "$file" ]; then
                            echo "$lib_dir/$(basename "$file")"
                            return 0
                        fi
                    done
                done
            else
                if [ -e "$lib_prefix/$lib_dir/$lib" ]; then
                    echo "$lib_dir/$lib"
                    return 0
                fi
            fi
        done
    done
    Error "Can't find library $lib"
}


# Outputs a list of all the library dependencies of the given executable
# files.  Called as
#
#   list_dependencies root files
#
list_dependencies()
{
    local root="$1"
    shift
    local file
    for file; do
        "$READELF" -d "$root/$file" |
        sed -n '/(NEEDED)/{s/^.*\[//; s/\].*$//; p; }' ||
            Error "Error reading file: $root/$file"
    done |
    sort | uniq |
    while read -r; do
        locate_library "$REPLY"  ||  exit 1
    done
}


# Given a library identified by locate_library returns the true path to that
# library.
library_path()
{
    for lib_prefix in "$SYSROOT" "$LIB_PREFIX"; do
        if [ -e "$lib_prefix/$1" ]; then
            echo "$lib_prefix/$1"
            return 0
        fi
    done
    Error "That was unexpected"
}


# -----------------------------------------------------------------------------

# Resolve all the library dependencies.  From the list of installed files and
# the list of extra libraries we work out which libraries need to be installed
# for a working system.


# Compute the initial list of libraries.  This list is always maintained in
# order so that the set difference in the resolution loop below works.
LIBS="$(
    {
        # For all installed files we generate the list of libraries needed by
        # the loader.
        DEPENDENCIES="$(cat "$install_list")"  &&
        list_dependencies '' $DEPENDENCIES  &&

        # For all extra libraries we resolve the library name.  Here we search
        # quite hard for the file in question so that it does not have to be
        # specified too exactly.
        for lib in $EXTRA_LIBS; do
            locate_library $lib '' '.so.*' '.so' '-*.so'  ||  exit 1
        done
    } |
    sort | uniq )"  ||
    Error "Error finding libraries"

# This is the tricky bit.   ND is "new dependencies", we start with the
# entire library as dependencies, and only inspect genuinely new dependencies
# on each fresh round.
ND="$LIBS" 
while :; do
    # Resolve all the dependencies from our new list
    ND="$(list_dependencies "$SYSROOT" $ND | sort | uniq)"
    # and subtract from this list the libraries we're already installing
    ND="$(comm -13 <(echo "$LIBS") <(echo "$ND"))"
    # If nothing new we're done
    [ -z "$ND" ]  &&  break
    # otherwise add to the list of libraries and go around again.
    LIBS="$(sort <<<"$LIBS"$'\n'"$ND" | uniq)"
done

# Now install all the libraries.
for lib in $LIBS; do
    lib_path="$(library_path "$lib")"  &&
    if [ -L "$lib_path" ]; then
        filename="$(readlink "$lib_path")"  &&
        ln -s "$filename" "$sysroot/$lib"  &&
        lib="$(dirname "$lib")/$filename"
    fi  &&
    cp "$lib_path" "$sysroot/$lib"  &&
    do_strip "$sysroot/$lib"  &&
    chmod -w "$sysroot/$lib"  ||
        Error "Error installing libraries"
done


install_terminfo $TERMS
